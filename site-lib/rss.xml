<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian Vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Obsidian Vault</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 16 Jan 2026 01:20:47 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 16 Jan 2026 01:20:44 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Queues]]></title><description><![CDATA[
First in First out data structure
items added to the back of the queue, removed from the front Breadth First Search Example: floodfill Tash Scheduling Example: Queue of work items, worker pull items off of queue for processing Message and Event Management
Parsing
It contains the following:push(T) // add element to back of queue
pop() // remove element from front of queue
T front() // access element at front of queue
T back() // access element at back of queue
bool empty() // return true if empty
size_t size() // return number of elements in queue Use when you don't need a custom queue. It is templatized You can implement it with an Array, Linked list, or even Both!
The STL Deque maintains a list of arrays, and STL Queue actually uses Deque by default! Every item has a priority associated with it
An element with higher priority gets dequeued before lower priority items
if two elements have the same priority, it's implementation dependent Task Scheduling
ER Patients
Path finding (Dikjstra's Algo, A*)
Graph Optimization
Huffman Coding
etc. Can be implemented using a queue and array
/*
INCLUDES &amp; NAMESPACES HERE
*/
class PQArray{
private: int data[10]; const int maxSize = 10; int currSize = 0;
public: bool isEmpty(){ return this-&gt;currSize == 0; } bool enqueue(int item){ if (currSize == 10) return false; data[currSize] = item; currSize++; //Use while loop for efficienty for (int idx = currSize -1; idx &gt; 0; idx--){ if (data[idx] &gt; data[idx-1]){ std::swap(data[idx], data[idx-1]); } } } bool dequeue(){ //Implementation Here } bool peekFront(int&amp; item){ //Implementation Here }
}; If we implement a P Queue ordinarily, we will get , but with If we implement it with heap, we can achieve time complexity
It contains the following:void push(T element) // add member void pop() // remove top member
const T&amp; top(); // return const reference to top member bool empty(); // return true if empty, false otherwise
size_t size(); // return number of elements By default it orders items where highest value dequeues first
You can specify a comparator in the template args for custom ordering
// Max-heap for integers std::priority_queue&lt;int&gt; pq; // Min-heap for integers std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; min_pq;
Using a Functor:
when we use a custom operator, we must supply it as a functor. It's a class tat implements operator().
// order elements by priority DESC, seqno ASC
class CustomComparator {
public: bool operator()(const PQItem&amp; first, const PQItem&amp; second) { if (first.priority == second.priority) { return first.seqno &gt; other.seqno; } else { return first.priority &lt; second.priority; }
};
Using operator&lt;:// compare by priority first, use seqno for tiebreaker. template &lt;typename T&gt;
class PQItem {
public: T value; unsigned priority; unsigned seqno; PQItem(T value, unsigned priority) : value(value), priority(priority), seqno(nextSeqno()) {} // define operator &lt; or use custom comparator bool operator&lt;(const PQItem&lt;T&gt;&amp; other) const { if(priority == other.priority) { return seqno &gt; other.seqno; } else { return priority &lt; other.priority; } }
};
]]></description><link>queues.html</link><guid isPermaLink="false">School/CSS 343/Queues.md</guid><pubDate>Fri, 16 Jan 2026 01:06:33 GMT</pubDate></item><item><title><![CDATA[README]]></title><description><![CDATA[ Dependencies <a data-href="Bitwise Operations" href="bitwise-operations.html" class="internal-link" target="_self" rel="noopener nofollow">Bitwise Operations</a> <br>
<a data-href="Coding Guidelines CSS 343" href="coding-guidelines-css-343.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Guidelines CSS 343</a> <br>
<a data-href="Queues" href="queues.html" class="internal-link" target="_self" rel="noopener nofollow">Queues</a> <br>
<a data-href="README" href="readme.html" class="internal-link" target="_self" rel="noopener nofollow">README</a> <br>
<a data-href="Trees" href="trees.html" class="internal-link" target="_self" rel="noopener nofollow">Trees</a> ]]></description><link>readme.html</link><guid isPermaLink="false">School/CSS 343/README.md</guid><pubDate>Thu, 15 Jan 2026 23:57:24 GMT</pubDate></item><item><title><![CDATA[Trees]]></title><description><![CDATA[
They are very good for adding and deleting
Quite a few applications, which include: Huffman Tree for Comparison
Ternary Trees for text search
Red/Black Trees for language parsing
Literally anything Hierarchical <img alt="Tree Traversal Example Tree.png" src="dependencies/tree-traversal-example-tree.png" target="_self" style="width: 400px; max-width: 100%;">
Used for ExamplesDefinition
Visit the root first, then recursively traverse the left subtree, then the right subtree.
Phrase PREpare My Little Rat (Pre: Me Left Right)
Example 1,2,4,5,3,6,7
Definition
Recursively traverse the left subtree, visit the root, then traverse the right subtree.
Phrase IN Leaving Mail Responsibly (In: Left Me Right)
Example 4,2,5,1,6,3,7
Definition
Recursively traverse the left subtree, then the right subtree, and visit the root last.
Phrase POST Letters Really Meticulously (Post: Left Right Me)
Example 4,5,2,6,7,3,1 Number of Nodes between the root and a leaf. The Root has a height of 0. This is how Professor Reel Defined it. This is not fully conventional as some courses say the leaves have height 0 instead. Number of nodes necessary to make it to a selected node from the root The difference of heights of left and right subtrees at any node is . It is complete when All levels of the tree are filled completely except for the lowest level nodes which are filled as much from the left as possible. A binary tree where each node has either 0 or 2 children. Each parent node has only one child node. Each node to the left is less than it's parent node, and each node on the right is greater than it's parent node.
items get added in order Can become unbalanced based on insertion order. Any internal nodes correspond to a operator, and any leaf nodes are operands (like numbers)
<br> <img alt="Expression Tree Example.png" src="dependencies/expression-tree-example.png" target="_self">
The tree above corresponds to: Use Post-Order Traversal to calculate the result
can be compiled into a stack for evaluation. Evaluate tokens left to right
If it's a number, push to stack
If it's an operator, pop operands from stack, evaluate, and then push result back
When Fully complete, the stack will only contain the final answer. A Common Form of Compression
It assigns variable length codes to symbols based on their frequency of occurrence (More frequent ones get shorter codes)
30-50% compression rate (for raw text)
Lossless!
Used in common things like ZIP, PNG, MP3, JPEG! Build a binary tree starting with nodes that appear less frequently
assign 0 and 1 to the edge of it's left and right children
follow the edges from the root to find the Huffman code
makes sure no piece of data will have the same encoding as another piece of data Create a leaf node for each unique character in the input.&nbsp; The node should contain the character and its frequency.
Dump all of the nodes into a priority queue (min-heap).
Extract the two nodes with the lowest frequencies from the queue
Create a new internal node with a frequency equal to the sum of the two nodes.&nbsp; Make the first extracted node the left child and the other the right child.&nbsp; Add the internal node to the queue.
Repeat steps 3 &amp; 4 until the queue contains only one node.
]]></description><link>trees.html</link><guid isPermaLink="false">School/CSS 343/Trees.md</guid><pubDate>Thu, 15 Jan 2026 02:14:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Bitwise Operations]]></title><description><![CDATA[
Bitwise operations are operations that directly manipulate individual bits (0s and 1s) of binary numbers using logical operators like AND, OR, XOR, NOT, and bit shifts. If you write in C++, there's a great chance you will need to use it sooner or later.
Most popular languages support bitwise operations
Bitwise operators are best aligned with when you use C/C++ since the languages are usually used when you need to do fine-grained bit manipulation Base Meaning: The number of unique digits a system uses (EX: Base 10 uses 0–9)
Decimal Number Meaning: Normal number: base 10 EX: 1785
Binary Number Meaning: Base 2, uses 0 and 1 EX: 11011111001
Octal Number Meaning: Base 8, uses 0–7 EX: 3361
Hexadecimal Number Meaning: _Base 16, uses 0–9 and A–F EX: 6F9 Decimal: No Prefix; EX: 1785
Binary: Prefix: 0b or 0B; EX: 0b10110
Octal: Prefix: Leading 0; EX: 0361 Valid pre-C++14, or rather discouraged in newer versions
Hex: Prefix: 0x or 0X; EX: 0x6F9
NOTE: you could just convert everything to binary and then convert to whatever base you'd like.Rule: Repeatedly divide by 2 and write down the remainders (bottom to top).
Example13 ÷ 2 = 6 remainder 1 6 ÷ 2 = 3 remainder 0 3 ÷ 2 = 1 remainder 1 1 ÷ 2 = 0 remainder 1
Result: *1101*Rule: Divide by 8 and write remainders (bottom to top).
Example83 ÷ 8 = 10 remainder 3 10 ÷ 8 = 1 remainder 2 1 ÷ 8 = 0 remainder 1
Result: *123*Rule: Divide by 16 and use letters A–F for 10–15.
Example254 ÷ 16 = 15 remainder 14 15 = F, 14 = E
Result: *FE*Rule: Multiply each bit by 2 raised to its position power, then add them all together.
Example(1 × 2⁴) + (0 × 2³) + (1 × 2²) + (1 × 2¹) + (0 × 2⁰) = 16 + 0 + 4 + 2 + 0 = 22₁₀
Result: 22Rule: Group bits into sets of 3 from right to left, then convert each group to its decimal value.
ExampleGroup bits into 3s from right: 110 101 110 → 6 101 → 5
Result: 65Rule: Group bits into sets of 4 from right to left, then convert each group to its hexadecimal value.
ExampleGroup bits into 4s from right: 1110 1110 1110 → E 1110 → E
Result: EERule: Multiply each digit by 8 raised to its position power, then add them all together.
Example347₈ = (3×8²) + (4×8¹) + (7×8⁰) = 231₁₀
Result: 231Rule: Replace each octal digit with its 3-bit binary equivalent.
Example347₈ → 3 4 7 → 011 100 111 → 011100111₂
Result: 011100111Rule: First convert octal to binary, then group the binary digits into 4s to get hexadecimal.
Example:347₈ → 011100111₂ → 0001 1100 1111 → 1CF₁₆
Result: 1CFRule: Multiply each digit by 16 raised to its position power, then add them all together.
Example2F₁₆ = (2×16¹) + (15×16⁰) = 47₁₀
Result: 47Rule: Replace each hex digit with its 4-bit binary equivalent.
Example2F₁₆ → 2 F → 0010 1111 → 00101111₂
Result 00101111Rule: Convert hex to binary, then group the binary digits into 3s from right to left to get octal.
Example2F₁₆ → 00101111₂ → 000 010 111 1 → 057₈
Result: 057
Compare each bit at the same position in the integer
If both are 1, then the result is 1. Any other case doesn't result in this (0).
unsigned result = 7&amp;4; //Equals 4 1 1 1
&amp; 1 0 0
--------- 1 0 0
7 is 111, and 4 is 100
Compare each bit at the same position in the integer
if either of them is 1, then the result is 1. if both are 0, the result is 0.
unsigned result = 7|4; //Equals 7 1 1 1
| 1 0 0
--------- 1 1 1
7 is 111, and 4 is 100
Compare each bit at the same position in the integer
if the bits are the same, it will be 0. if they are different, it is 1.
It's a reversable process (The reason it's used often!) A ^ B ^ B = A
unsigned result = 7^4; //Equals 3 1 1 1
^ 1 0 0
--------- 0 1 1
7 is 111, and 4 is 100
Preformed on a single number.
Will essentially make any 1 to a 0, and 0 to a 1. it's "complement"
unsigned result = ~4; //Equals 3 Be aware of bit length, because this final value can be very different. this is only true for 3 bits. C++ doesn't choose 3 bit as default.~ 1 0 0
--------- 0 1 1
4 is 100
Shifts bits of an integer to the left by a specific number of positions.
Same thing as # unsigned result = 5&lt;&lt;2; //Equals 200 0 0 0 0 1 0 1 &lt;&lt; 2
---------------
0 0 0 1 0 1 0 0 Shifts bits of an integer to the right by a specific number of positions.
Same thing as # unsigned result = 16&gt;&gt;2; //Equals 40 0 0 1 0 0 0 0 &gt;&gt; 2
---------------
0 0 0 0 0 1 0 0 In C++ shifting by 0 bytes doesn't do anything
Don't shift by equal or more than the available bit length, it's undefined behavior.
You can make constraints to help with the previous point. Endianness describes how multi-byte values are laid out in memory. The Least Significant Byte is stored at the lowest memory address.
This is used by Intel (x86 &amp; x64) CPUs. And by most modern computers.
Example
uint32_t x = 0xA1B2C3D4;
Memory Storage (low high)D4 C3 B2 A1 The Most Significant Byte is stored at the lowest memory address.
Used by network protocols, and similar systems.
Memory Storage (low high)
A1 B2 C3 D4 There must be a predetermined format for different processes to read the bytes. Especially when sending data over network.
NOTE: C/C++ provides conversion helpers to convert between the two. Flags are individual bits packed into an integer, where each bit represents an on/off option.
Extremely common in system calls, file I/O, graphics APIs, embedded systems, and OS kernels.
Using flags avoids passing many separate boolean parameters. Compact (32 or 64 options in a single integer)
Fast &amp; cheap on hardware
Easily to create
namespace OpenFlags {
constexpr uint32_t READ = 1 &lt;&lt; 0; // 0001
constexpr uint32_t WRITE = 1 &lt;&lt; 1; // 0010
constexpr uint32_t APPEND = 1 &lt;&lt; 2; // 0100
constexpr uint32_t TRUNC = 1 &lt;&lt; 3; // 1000
} A bitset is a collection of bits where each bit is like a boolean value.
Similar to a boolean array, but way more memory efficient. Each bit position represents an index or ID
Stored using integers or arrays of bytes
Example
friend list encoded in a uint16_t
// bit positions: [15 ... 0]
uint16_t recipients = (1 &lt;&lt; 0) | (1 &lt;&lt; 4) | (1 &lt;&lt; 7); Very compact
CPU Cache-friendly
Ideal for large datasets or tight memory constraints
#include &lt;bitset&gt;
std::bitset&lt;128&gt; users;
users.set(5);
users.reset(12);
users.flip(7); Size fixed at compile time
Bounds-checked access (safer than manual bit math)
Very fast Keeping many boolean values as bool is memory-inefficient.
A bool usually uses 1 byte, even though it only needs 1 bit. 50 boolean values bool flags[50] → 50 bytes
Bitfield → 50 bits (~7 bytes) uint64_t features = 0;
features |= (1ULL &lt;&lt; 3); // enable feature 3
features |= (1ULL &lt;&lt; 10); // enable feature 10
bool enabled = features &amp; (1ULL &lt;&lt; 10); Large datasets
Performance-critical code (For systems with low power microcomputers) Like when coding an STM microcontroller!
Memory-constrained systems Compression often uses bit packing (like Huffman coding) Hash functions use XOR and shifts for mixing bits
Used when creating as unique a value as possible Uses bitwise logic to combine images via masks.
Background:
1010101010
1010101010
1010101010
1010101010
1010101010
1010101010 Mask: 1111001111
1111001111
0000000000
0000000000
1111001111
1111001111 Image:
0000110000
0000110000
1111001111
1111001111
0000110000
0000110000 Final:
1010111010
1010111010
1111001111
1111001111
1010111010
1010111010
background | mask &amp; image = final_composite
PATRICIA Tries
Radix-2 Sort
Locality Sensitive Hashing
Bloom Filters
HyperLogLog
Storage allocation bitmaps
Network message
]]></description><link>bitwise-operations.html</link><guid isPermaLink="false">School/CSS 343/Bitwise Operations.md</guid><pubDate>Thu, 15 Jan 2026 02:14:02 GMT</pubDate></item><item><title><![CDATA[Huffman Coding Example - Lecture Slides]]></title><description><![CDATA[<img src="dependencies/huffman-coding-example-lecture-slides.png" target="_self">]]></description><link>dependencies/huffman-coding-example-lecture-slides.html</link><guid isPermaLink="false">School/CSS 343/Dependencies/Huffman Coding Example - Lecture Slides.png</guid><pubDate>Mon, 12 Jan 2026 02:12:45 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Expression Tree Example]]></title><description><![CDATA[<img src="dependencies/expression-tree-example.png" target="_self">]]></description><link>dependencies/expression-tree-example.html</link><guid isPermaLink="false">School/CSS 343/Dependencies/Expression Tree Example.png</guid><pubDate>Mon, 12 Jan 2026 01:48:30 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Tree Traversal Example Tree]]></title><description><![CDATA[<img src="dependencies/tree-traversal-example-tree.png" target="_self">]]></description><link>dependencies/tree-traversal-example-tree.html</link><guid isPermaLink="false">School/CSS 343/Dependencies/Tree Traversal Example Tree.png</guid><pubDate>Sun, 11 Jan 2026 04:48:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Coding Guidelines CSS 343]]></title><description><![CDATA[These guidelines define naming conventions and basic style rules to promote readability, consistency, and maintainability across all CSS 343 programming assignments.Definition: Each word starts with a capital letter.Examples:
RedTop
FirstInLine
BigScaryMonster
Usage:
Class names
Structs or types (if applicable)
Definition: The first word starts with a lowercase letter; subsequent words start with a capital letter.Examples:
blueThing
sock
theItem
lastInLine
Usage:
Function names
Parameters
Accessors (e.g., getValue(), setValue())
Local variables
Private class members
Definition: All letters are uppercase, with words separated by underscores.
Examples:const int CARDS_IN_DECK = 52;
Usage:
Constants
Compile-time fixed values Be consistent with naming and formatting throughout your code
Avoid ambiguous or misleading names
Write code that is easy for others (and your future self) to understand
]]></description><link>coding-guidelines-css-343.html</link><guid isPermaLink="false">School/CSS 343/Coding Guidelines CSS 343.md</guid><pubDate>Sun, 11 Jan 2026 04:37:16 GMT</pubDate></item></channel></rss>